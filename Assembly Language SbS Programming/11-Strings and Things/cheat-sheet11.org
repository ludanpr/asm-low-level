* Capítulo 11 - Strings and Things
  As instruções de /string/ x86 são capazes de tratar de longas sequências de /bytes/, /words/, /dwords/ na memória de uma só vez.
  (Na linguagem /assembly/, qualquer sequência contígua de bytes na memória pode ser considerada uma /string/).

** The Notion of an Assembly Language String
   Em uma visão geral, uma /string/ é qualquer grupo de bytes contíguos na memória, de tamanho arbitrário, que o sistema operacional
   permite. O conceito primário de definição de uma /string/ em linguagem /assembly/ é que os seus /bytes/ componentes estão contíguos,
   sem interrupções.

   Em assembly, nós devemos pensar em uma /string/ em termos dos valores de registrador que as define. Você tem uma /string/ quando você
   coloca o seu endereço em um registrador. E uma vez que o registrador aponte para a /string/, o tamanho dessa /string/ é definido pelo
   valor que você coloca no registrador =ECX=.

** Source Strings and Destination Strings
   Existem dois tipos de /strings/ em assembly x86. /Strings fonte/ são /strings/ das quais você lê. /Strings destino/ são /strings/ para
   as quais você escreve. A diferença entre as duas é somente uma questão de registradores; /strings/ fonte e /strings/ destino podem ter
   intersecção. De fato, a mesma região de memória pode ser ambas uma /string/ fonte e uma /string/ destino, ao mesmo tempo.

   As suposições que a CPU faz ao executar uma instrução de /string/ em modo protegido 32-bit:

   * Uma /string/ fonte é apontada por =ESI=.
   * Uma /string/ destino é apontada por =EDI=.
   * O tamanho de ambos os tipos de /string/ é o valor que você coloca em =ECX=. Como a
     CPU age sobre esse tamanho depende da instrução específica e como ela está sendo usada.
   * Dados vindo de uma /string/ fonte ou indo para uma /string/ destino devem iniciar,
     terminar, ou passar, pelo registrador =EAX=.

** REP STOSB, the Software Machine Gun

*** Machine-Gunning the Virtual Display
    Quando o Linux carrega os programas na memória, ele tipicamente limpa variáveis não inicializadas (como =VidBuff= no exemplo em =vidbuff1.asm=)
    sobrescrevendo-as com zeros binários. Mas os zeros binários não são exibidos corretamente no console. Para dar a aparência de "espaço em branco"
    no console, a memória do /buffer/ que será exibido deve ser escrita com o caractere ASCII de espaço (=27= ou =20h=).

    A maneira mais simples de fazer isso é colocando o endereço do buffer que será exibido em =EDI=, o número de bytes no buffer em =ECX=, e o valor
    do caractere ASCII em =AL=, e codificar um /loop/ da seguinte forma:

    #+BEGIN_SRC nasm
    Clear:
      mov byte [edi],al
      inc edi
      dec ecx
      jnz Clear
    #+END_SRC

    Isso até é toleravelmente rápido, mas esse código é equivalente a:

    #+BEGIN_SRC nasm
    rep stosb
    #+END_SRC

    A instrução =STOSB= é a mais simples das instruções de /string/. A instrução mostrada acima possui duas partes. =REP= é chamado de /prefixo/, e ele
    modifica como a CPU trata o mnemônico da instrução que o segue.

    O mnemônico =STOSB= significa *STOre String by Byte*. =STOSB= funciona somente na /string destino/. As suposições feitas pela CPU quando do uso de
    =STOSB= são:

    * =EDI= deve estar armazenando o endereço da /string destino/.
    * =ECX= deve estar armazenando o número de vezes que o valor em =AL= será colocado na /string/.
    * =AL= deve estar armazenando o valor a ser armazenado na /string/.

    *Em resumo, REP STOSB escreverá o valor em AL por ECX vezes no endereço apontado por EDI.*

*** Executing the STOSB Instruction
    Uma vez que você tenha arranjado da forma descrita anteriormente os registradores =EDI=, =ECX=, e =AL=, você pode executar com segurança a instrução
    =STOSB=. Quando executada, é isso o que acontece:

    1. O valor do byte em =AL= é copiado para o endereço de memória armazenado em =EDI=.
    2. =EDI= é incrementado em 1, tal que ele agora aponta para o próximo byte na memória
       seguindo o que acaba de ser escrito.

    Note que nós ainda não estamos "metralhando" (/machine-gunning/) nada ainda. /Uma/ cópia de =AL= é copiada para /uma/ localização na memória.

    Um ponto importante a se lembrar é que =ECX= não é decrementado por =STOSB=. =ECX= é decrementado automaticamente *somente* se você usar o prefixo =REP=
    com =STOSB=.

    Então, você não pode fazer =STOSB= executar automaticamente se não usar o prefix =REP=.

    O que o prefixo =REP= faz é simples: ele faz o arranjo de um /loop/ muito eficiente completamente /dentro/ da CPU, e escreve cópias de =AL= para a memória
    repetidamente, incrementando =EDI= por 1 e decrementando =ECX= em 1 a cada vez, até que =ECX= atinja o valor 0.

    É exatamente isso que essa parte do código faz:

    #+BEGIN_SRC nasm
    cld                   ; clear DF
    mov al,FILLCHR
    mov edi,VidBuff
    mov ecx,VIDBUFFLEN
    rep stosb
    #+END_SRC

*** STOSB and the Direction Flag
    A instrução =CLD= controla algo crucial ao trabalharmos com instruções de /string/, que é a direção que a operação de /string/ segue na memória.

    É possível arranjar para que a direção de memória que a instrução =STOSB= quando executada automaticamente siga seja crescente ou decrescente. Isto é, se
    queremos caminhar na memória de um endereço menor para um endereço maior (incrementando =EDI=) ou de um endereço maior para um endereço menor (decrementando
    =EDI=).

    A direção de memória que =STOSB= seguirá é controlada pela /flag de direção/ (/Direction Flag/) no registrador =EFLAGS=.

    Quando DF está em /set/, =STOSB= e as outras instruções de /string/ que possuem o mesmo comportamento caminharão na memória de um endereço maior para um
    endereço menor, decrementando =EDI=. Quando DF está em /clear/, essas instruções caminharão na memória de um endereço menor para um endereço maior, incrementando
    =EDI=.

    A instrução =CLD= faz o /clear/ de DF, e a instrução =STD= faz o /set/ de DF.

** The Semiautomatic Weapon: STOSB without REP
   =STOSB=, sem o prefixo =REP=, pode ser utilizado para armazenar valores diferentes de =AL= (no caso de o programador modificar =AL= a cada passagem do laço) em =EDI=.

*** The LOOP Instructions
    Com isso em mente, considere a seguinte instrução /assembly/ =loop=.

    #+BEGIN_SRC nasm
    DoChar:
      stosb

      add al,'1'
      aaa                   ; Adjust AX to make this BCD addition
      add al,'0'            ; Put binary 3 in AL's high nybble

      dec ecx
      jnz DoChar
    #+END_SRC

    Note que esse código faz o que foi sugerido anteriormente, modifica =AL= a cada passagem do laço e usa =STOSB= sem o prefixo =REP=.

    O mesmo comportamento desse código pode ser implementado com a instrução =LOOP=. Essa instrução combina o decremento de =ECX= com um teste e /jump/ baseado em ZF (Zero Flag):

    #+BEGIN_SRC nasm
    DoChar:
      stosb
      add al,'1'
      aaa
      add al,'0'
      loop DoChar
    #+END_SRC

    A instrução =loop= primeiro decrementa =ECX= em 1. Ela então verifica ZF para ver se a operação de decremento forçou =ECX= para o valor zero. Se esse for o caso, ela permite
    a sequência para a próxima instrução. Se não, =loop= faz o /jump/ para o rótulo especificado como seu operando.

*** Displaying a Ruler on the Screen
    Como uma demonstração útil de quando faz sentido usar =STOSB= sem =REP= (mas com =LOOP=), nós escrevemos =Ruler=.

    O procedimento =Ruler= exibe uma sequência repetida de dígitos ascendentemente iniciando de =1=, de qualquer tamanho, em alguma localização selecionada da tela.

    O procedimento =Ruler= permite que você especifique quão longa é a sequência exibida, em dígitos, e onde na tela ela será exibida.

    Uma chamada típica para =Ruler= é algo como:

    #+BEGIN_SRC nasm
    mov eax,1              ; Load Y position
    mov ebx,1              ; Load X position
    mov ecx,COLS-1         ; Load ruler length (-1 because of EOL)
    call Ruler
    #+END_SRC

    Essa chamada posiciona a sequência no canto superior esquerdo do /display/, iniciando na posição 1,1.
    
*** MUL Is Not IMUL
    O procedimento =Ruler= usa =MUL= para calcular uma posição X,Y no /buffer/ de exibição onde =STOSB= pode iniciar a colocar os caracteres da sequência.

    Você deve mover =Y= linhas para baixo no /buffer/ da tela, e depois mover =X= /bytes/ a partir da margem esquerda na tela para chegar à posição =X,Y=. O cálculo é feito dessa
    forma dentro do procedimento =Ruler=:

    #+BEGIN_SRC nasm
    mov edi,VidBuff
    dec eax                ; Adjust Y value down by 1 for address calculation
    dec ebx                ; Adjust X value down by 1 for address calculation
    mov ah,COLS            ; Assumes Y position fits in 8-bit AL
    mul ah                 ; 8-bit multiply AL*AH to AX
    lea edi,[edi+eax]      ; Add Y offset into VidBuff
    lea edi,[edi+ebx]      ; Add X offset into VidBuff
    #+END_SRC

    Para uma multiplicação de valores de 8 bits usando =MUL=, um dos fatores é implícito: =AL= contém o valor =Y=, e o chamador passa para =Ruler= o valor =Y= em =EAX=. Nós colocamos
    a largura da tela em =AH=, e depois multiplicamos =AH*AL= com =MUL=. O produto substitui o valor de ambos =AL= e =AH=, e é acessado como o valor em =AX=.

    Agora, existe um /bug/ bastante comum: =MUL= não é =IMUL= - a maior parte do tempo. =MUL= trata os valores de seus operandos como valores sem sinal, enquanto =IMUL= trata seus
    operandos como valores com sinal. Essa diferença não importa enquanto ambos os valores são positivos em um contexto com sinal. Em termos práticos para uma multiplicação de
    8 bits, =MUL= e =IMUL= funcionam de forma idêntica em valores 127 ou menos. No valor 128 tudo muda. Valores acima de 127 são considerados negativos em um contexto de 8 bits com
    sinal. =MUL= considera 128 como 128. =IMUL= considera 128 como -1.

*** Adding ASCII Digits
    Imediatemente antes da instrução =STOSB=, nós carregamos o dígito ASCII ='1'= em =AL=. Note que ='1'= em =MOV AL,'1'= é um caractere ASCII, com valor numérico =31h=.

    Isso se torna um problema imediatamente após armazenarmos o dígito ='1'= na memória de vídeo com =STOSB=. Depois do dígigo ='1'= nós precisamos armazenar o dígito ='2'= - e para
    fazê-lo, nós precisamos mudar o valor em =AL= de ='1'= para ='2'=.

    Uma adição simples não funcionará. Então a instrução =AAA= (/Adjust AL after BCD Addition/) entra em cena.

    O que =AAA= faz é permitir que nós adicionemos dígitos ASCII de fato, em vez de valores numéricos. =AAA= é uma de uma grupo de instruções chamado de instruções BCD, assim chamado
    por suportar aritmético com valores /Binary Coded Decimal/ (BCD).

    O valor =31h= é um valor BCD válido, porque o /nybble/ menor contém =1=. BCD é um sistema numérico de 4 bits, e o /nybble/ maior é ignorado.

    =AAA= basicamente faz duas coisas:

    * Força o valor nos 4 bits menores de =AL= para um valor entre 0 e 9 se eles são maiores
      que 9. Isso é feito adicionando 6 a =AL= e depois forçando o /nybble/ alto de =AL= para
      0.
    * Se o valor em =AL= teve que ser ajustado, isso indica que houve um /carry/ na adição, e
      por isso =AH= é incrementado. =CF= e =AF= recebem um /set/.

    Isso permite que nós adicionomes dígitos ASCII tais como =1= e =2= usando a instrução =ADD=. =Ruler= faz isso imediatamente depois da instrução =STOSW=:

    #+BEGIN_SRC nasm
    add al,'1'
    aaa
    #+END_SRC

    Se antes da adição os conteúdos do menor /nybble/ de =AL= fosse =9=, adicionar =1= geraris o valor =0AH=, que não é um valor BCD válido. =AAA= então ajustaria =AL= adionando 6 a
    =AL= e fazendo o /clear/ do maior /nybble/. Adicionar 6 a =0AH= resulta em =10H=, e quando o maior /nybble/ recebe um /clear/, o resultado é =OH=. =AH= seria incrementado em 1.

*** Adjusting AAA's Adjustments
    Ainda há um problema: =AAA= faz o /clear/ do maior /nybble/. Isso significa que adicionar ='1'= e ='1'= não gerará ='2'= . Em vez disso, =AL= torna-se 2 binário. Para fazer
    dos conteúdos de =AL= um dígito ASCII exibível novamente, nós devemos adicionar =30h= a =AL=. Isso é fácil, apenas adicione =0= a =AL=, que possui o valor numérico =30H=. Então,
    adicionar =0= faz =02h= de volta para =32h=, que é o valor numérico equivalente ao dígito ASCII ='2'= . Essa é a razão para a instrução =ADD AL,'0'=.

*** 16-bit and 32-bit Versions of STOS
    Há três "tamanhos" diferentes da instrução de /string/ =STOS=: /byte/, /word/, e /dword/. =STOSB= é a versão de tamanho de /byte/. =STOSW= armazena o valor de 16 bits em =AX= na
    memória, e =STOSD= armazena o valor de 32 bits em =EAX= na memória.

    =STOSW= e =STOSD= praticamente da mesma forma que =STOSB=. A maior diferença mora na forma como =EDI= é modificado depois de cada operação de transferência de memória. Para
    =STOSW=, =EDI= muda por dois /bytes/ (para cima ou para baixo dependendo de =DF=). Para =STOSD=, =EDI= muda por 4 /bytes/.

** MOVSB: Fast Block Copies
   Assim como as instruções =STOS=, =MOVS= vêm em três "tamanhos": para tratar de /bytes/ (=MOVSB=), palavras de 16 bits (=MOVSW=), e /dwords/ de 32 bits (=MOVSD=).

   O funcionamento da instrução =MOVSB= é da seguinte forma: um bloco de memória no endereço armazenado em =ESI= é copiado para armazenado em =EDI=. O número de /bytes/ a serem
   movidos deve ser colocado no registrador =ECX=. =ECX= é decrementado depois que cada /byte/ é copiado, e os endereços em =ESI= e =EDI= são ajustados em 1. Esses ajustes são ou
   decrementos ou incrementos, dependendo do estado de =DF=.

   =MOVSB= pode operar semiautomaticamente ou automaticamente, assim como =STOSB=. Se o prefixo =REP= é adicionado a =MOVSB=, então (assumindo que seus registradores estão com os
   valores corretos) um bloco de memória será copiado de um para outro em apenas uma instrução.

*** DF and Overlapping Block Moves
    Nada obriga que =ESI= e =EDI= apontem para áreas inteiramente separadas da memória. Os blocos de memória fonte e destino podem ter intersecção, e isso frequentemente pode ser
    muito útil.

** Storing Data to Discontinuous Strings
   Até agora nós usamos as instruções de /strings/ assumindo que a /string/ destino é sempre uma sequência contínua de /bytes/ na memória. Esse não é necessariamente o caso. Em
   adição a mudar o valor em =EAX= entre execuções de =STOSB=, você pode modificar o /endereço de destino/ também. Como resultado, podemos armazenar dados em várias áreas diferentes
   da memória dentro de um único /loop/.

*** Nested Instruction Loops
    O laço interno exibe uma linha consistindo de 32 caracteres. O laço externo divide o /display/ em 7 dessas linhas.

    #+BEGIN_SRC nasm
    .DoChr:
        stosb
        jcxz AllDone
        inc al
        dec bl
        loopnz .DoChr
    #+END_SRC

    Mantenha em mente o que acontece cada vez que =STOSB= é usada: O caractere em =AL= é escrito na memória apontada por =EDI=, e =EDI= é incrementado em 1. Na outra extremidade
    do laço, a instrução =LOOPNZ= decrementa =ECX= em 1 e fecha o laço.

*** Jumping When ECX Goes to 0
    A instrução especial de /branch/ =JCXZ= foi criada especificamente para laços como o que usamos em =showchar.asm=. =JCXZ= não é afetada por nenhuma das /flags/ e nem decrementa
    nenhum registrador; ela é afetada pelo registrador =ECX=. Quando =ECX= se torna zero, =JCXZ= pula para o rótulo especificado.
